- [1. JavaScript](#1-javascript)
  - [1.1 浏览器执行 js](#11-浏览器执行-js)
  - [1.2 js 的组成](#12-js-的组成)
  - [1.3 js 的书写](#13-js-的书写)
  - [1.3 js 的注释](#13-js-的注释)
  - [1.4 js 输入输出语句](#14-js-输入输出语句)
- [2. 变量](#2-变量)
  - [2.1 变量使用](#21-变量使用)
  - [2.2 变量语法](#22-变量语法)
  - [2.3 变量的命名规格](#23-变量的命名规格)
- [3. 数据类型](#3-数据类型)
  - [3.1 变量的数据类型](#31-变量的数据类型)
  - [3.2 简单数据类型](#32-简单数据类型)
  - [3.3 获取变量数据类型](#33-获取变量数据类型)
  - [3.4 数据类型转换](#34-数据类型转换)
- [4. 运算符](#4-运算符)
  - [4.1 算数运算符](#41-算数运算符)
  - [4.2 递增和递减运算符](#42-递增和递减运算符)
  - [4.3 比较运算符](#43-比较运算符)
  - [4.4 逻辑运算符](#44-逻辑运算符)
  - [4.5 赋值运算符](#45-赋值运算符)
  - [4.6 运算符优先级](#46-运算符优先级)
- [5. JavaScript 流程控制-分支](#5-javascript-流程控制-分支)
  - [5.1 顺序流程控制](#51-顺序流程控制)
  - [5.2 分支流程控制](#52-分支流程控制)
    - [5.2.1 if 语句](#521-if-语句)
        - [案例 进入网吧](#案例-进入网吧)
        - [案例 判断闰年](#案例-判断闰年)
    - [5.2.2 switch 语句](#522-switch-语句)
    - [5.2.3 三元表达式](#523-三元表达式)
  - [5.3 循环流程控制](#53-循环流程控制)
    - [5.3.1 for 循环](#531-for-循环)
        - [断点调试](#断点调试)
    - [5.3.2 双重 for 循环](#532-双重-for-循环)
    - [5.3.3 while 循环](#533-while-循环)
    - [5.3.4 do while 循环](#534-do-while-循环)
    - [5.3.5 continue break](#535-continue-break)
- [6. JavaScript 数组](#6-javascript-数组)
  - [6.1 创建数组](#61-创建数组)
  - [6.2 获取数组元素](#62-获取数组元素)
  - [6.3 遍历数组](#63-遍历数组)
  - [6.4 数组中新增元素](#64-数组中新增元素)
        - [数组排序（冒泡排序）](#数组排序冒泡排序)
- [7. JavaScript 函数](#7-javascript-函数)
  - [7.1 函数的使用](#71-函数的使用)
  - [7.2 函数的参数](#72-函数的参数)
  - [7.3 函数的返回值](#73-函数的返回值)
  - [7.4 arguments 的使用](#74-arguments-的使用)
  - [7.5 函数可以调用另外一个函数](#75-函数可以调用另外一个函数)
  - [7.6 函数的两种声明方式](#76-函数的两种声明方式)
- [8. JavaScript 作用域](#8-javascript-作用域)
  - [8.1 变量的作用域](#81-变量的作用域)
  - [8.2 作用域链](#82-作用域链)
- [9. JavaScript 预解析](#9-javascript-预解析)
- [10. JavaScript 对象](#10-javascript-对象)
  - [10.1 创建对象的方式](#101-创建对象的方式)
        - [构造函数](#构造函数)
  - [10.2 new 关键字](#102-new-关键字)
  - [10.3 遍历对象属性](#103-遍历对象属性)
- [11. JavaScript 内置对象](#11-javascript-内置对象)
  - [11.2 查文档](#112-查文档)
  - [11.3 Math 对象](#113-math-对象)
  - [11.4 随机数方法 random()](#114-随机数方法-random)
  - [11.5 日期对象](#115-日期对象)
  - [11.6 数组对象](#116-数组对象)
        - [数组去重](#数组去重)
  - [11.7 字符串对象](#117-字符串对象)
- [12. JavaScript 简单类型与复杂类型](#12-javascript-简单类型与复杂类型)
  - [12.1 数据类型内存分配](#121-数据类型内存分配)
  - [12.2 数据类型传参](#122-数据类型传参)
- [13. 拓展](#13-拓展)
  - [13.1 编译语言和解释语言](#131-编译语言和解释语言)
  - [13.2 标识符、关键字、保留字](#132-标识符关键字保留字)
  - [13.3 JavaScript 命名规范以及语法格式](#133-javascript-命名规范以及语法格式)

**数据存储单位**

bit<byte<kb<GB<TB<...

- 位(bit)： 1bit 可以保存一个 0 或者 1 （最小的存储单位）
- 字节(Byte)：1B = 8b
- 千字节(KB)：1KB = 1024B
- 兆字节(MB)：1MB = 1024KB
- 吉字节(GB): 1GB = 1024MB
- 太字节(TB): 1TB = 1024GB

# 1. JavaScript

是一种运行在客户端的脚本语言。

- 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行

- 现在也可以基于 Node.js 技术进行服务器端编程

HTML/CSS 标记语言--描述类语言，js 脚本语言--编程类语言

## 1.1 浏览器执行 js

浏览器分成两部分：渲染引擎和 JS 引擎

- 渲染引擎：用来解析 HTML 与 CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit

- js 引擎：也称为 js 解释器。 用来读取网页中的 JavaScript 代码，对其处理后运行，比如 chrome 浏览器的 V8

js 引擎执行代码时<u>逐行解释每一句源码</u>（转换成机器语言）。

## 1.2 js 的组成

![](images\20201221092323.png)

- **ECMAScript**

ECMAScript 规定了坚实的编程语法和基础核心知识

- **DOM**

文档对象模型。

- **BOM**

浏览器对象模型。

## 1.3 js 的书写

**（1）行内式 js 直接写到元素的内部**

```html
<input type="button" value="xxx" onclick="alter('yyy')" />
```

- 可以将单行或少量 JS 代码写在 HTML 标签的事件属性中（以 on 开头的属性），如：onclick

- 在 HTML 中我们推荐使用双引号, JS 中我们推荐使用单引号

**（2）内嵌式 js**

```html
<script></script>
```

**（3）外部 js ， script 引入链接是双标签**

```html
<script src="xx.js"></script>
```

- 引用外部 JS 文件的 script 标签<u>中间不可以写</u>代码

## 1.3 js 的注释

```js
//	1.单行注释	ctrl+/
/*	2.多行注释	默认快捷键shift+alt+a
	2.多行注释	vscode中修改为 ctrl+shift+/
*/
```

## 1.4 js 输入输出语句

| 方法                | 说明                                             | 归属   |
| ------------------- | ------------------------------------------------ | ------ |
| prompt('内容')      | 浏览器弹出输入框，用户可以输入                   | 浏览器 |
| console.log('内容') | 浏览器控制台输出信息（console 给程序员测试用的） | 浏览器 |
| alert('内容')       | 浏览器弹出警示框                                 | 浏览器 |

# 2. 变量

- 变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。

- 变量是程序在内存中申请的一块用来存放数据的空间。

## 2.1 变量使用

**（1）声明变量**

```js
// 声明变量
var age; // 声明一个 名称为age 的变量
```

- var 是一个 JS 关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间
- age 是程序员定义的变量名

**（2）赋值**

```js
age = 10; // 给 age 这个变量赋值为 10
```

- = 用来把右边的值赋给左边的变量空间中
- 变量值是程序员保存到变量空间里的值

**变量的初始化** （声明一个变量并赋值）

```js
var age = 18; // 声明变量同时赋值为 18
var age = "内容"; // 声明变量同时赋值为 内容
```

## 2.2 变量语法

**（1）更新变量**

一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。

```js
var age = 18;
age = 81; // 最后的结果就是81因为18 被覆盖掉了
```

**（2）声明多个变量**

同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。

```js
var age = 10,
  name = "内容",
  sex = 2;
```

**（3）声明变量的特殊性**

| 情况                           | 说明                   | 结果            |
| ------------------------------ | ---------------------- | --------------- |
| `var age ; console.log (age);` | 只声明 不赋值          | undefined       |
| `console.log(age)`             | 不声明 不赋值 直接使用 | 报错            |
| `age = 10; console.log (age);` | 不声明 只赋值          | 10 //不建议使用 |

## 2.3 变量的命名规格

- 由字母(A-Za-z)、数字(0-9)、下划线(\_)、美元符号( $ )组成，如：usrAge, num01, \_name

- 严格区分大小写。var app; 和 var App; 是两个变量

- 不能 以数字开头。 18age 是错误的

- 不能是关键字、保留字。例如：var、for、while （name 既不是关键字也不是保留字，但是不建议使用）

- 变量名必须有意义。

- 遵守驼峰命名法。首字母小写，后面单词的首字母<u>需要大写</u>。 myFirstName

# 3. 数据类型

根据数据占的内存空间不同，所以划分数据类型。

数据类型的分类包括：<u>简单数据类型</u>、<u>复杂数据类型</u>。

## 3.1 变量的数据类型

JavaScript 是一种弱类型或者说动态语言。

```js
//var num；	这里的num 是不确定属于哪种数据类型
var num = 10; //num属于数字型
//js的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的
```

JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：

```js
var x = 6; // x 为数字
var x = "Bill"; // x 为字符串
```

## 3.2 简单数据类型

| 简单数据类型 | 说明                                               | 默认值    |
| ------------ | -------------------------------------------------- | --------- |
| Number       | 数字型，包含 整型值和浮点型值，如 21、0.21         | 0         |
| Boolean      | 布尔值类型，如 true、false，等价于 1 和 0          | false     |
| String       | 字符串类型，如“张三” 注意 js 里面，字符串都带引号  | “”        |
| Undefined    | var a; 声明了变量 a 但没有给值，此时 a = undefined | undefined |
| Null         | var a = null; 声明了变量 a 为空值                  | null      |

### **（1）数字类型 number**

数字类型既可以用来保存整数值，也可以保存小数(浮点数）。

```js
var age = 21; // 整数
var Age = 21.3747; // 小数
```

- **数字型进制**

最常见的进制有二进制、八进制、十进制、十六进制。

```js
// 1.八进制数字序列范围：0~7   程序里面数字前面加0，表示八进制
var num1 = 07; // 对应十进制的7
var num2 = 019; // 对应十进制的19
var num3 = 010;
console.log(num3); // 八进制 转换为十进制 对应十进制的8

// 2.十六进制数字序列范围：0~9以及A~F  程序里面数字前面加0x，表示八进制
var num = 0xa;
```

- **数字型范围**

JavaScript 中数值的最大值（Number.MAX_VALUE）和最小值（Number.MIN_VALUE）

```js
alert(Number.MAX_VALUE); // 最大值，1.7976931348623157e+308
alert(Number.MIN_VALUE); // 最小值，5e-324
```

- **数字型三个特殊值**

Infinity、-Infinity、NaN

```js
alert(Number.MAX_VALUE * 2); // 输出Infinity 代表无穷大，大于任何数值
alert(-Number.MAX_VALUE * 2); // 输出-Infinity 代表无穷小，小于任何数值
alert("内容" - 100); // 输出NaN，Not a number 代表一个非数值
```

- **isNaN**()

这个方法用来判断非数字，并且返回一个值 如果是数字返回 false，如果不是数字返回的是 true

---

### **（2）字符串型 string**

字符串型可以是引号中的任意文本，其语法为 双引号 "" 和 单引号''。

html 标签里面的属性使用的是双引号，js 这里我们更推荐使用单引号。

- **字符串引号嵌套**

js 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (**外双内单，外单内双**)

```js
var strMsg = '我是"xxx"'; // 可以用''包含""
```

- **字符串转义符**

类似 HTML 里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。

转义符都是 \ 开头的，这些转义字符要写到引号里面。

| 转义符 | 解释说明 |
| ------ | -------- |
| `\n`   | 换行符   |
| `\\`   | 斜杠 \   |
| `\'`   | ' 单引号 |
| `\"`   | ” 双引号 |
| `\t`   | tab 缩进 |
| `\b`   | 空格     |

- **字符串长度**

通过字符串的 length 属性可以获取整个字符串的长度。

```js
var strMsg = "hello world！";
alert(strMsg.length); // 显示 12
```

- **字符串的拼接**

多个字符串之间可以使用 + 进行拼接，其拼接方式为:

**字符串 + <u>任何类型</u> = 拼接之后的新字符串。**

```js
console.log(12 + 12); //24
console.log("12" + 12); //字符串'1212'
//+号总结口诀：数值相加 ，字符相连
```

```js
//变量不要写到字符串里面，是通过和字符串相连的方式实现
console.log("某某" + age + "岁");
//变量和字符串相连口诀： 引引加加
```

### （3）布尔型 boolean

布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。

布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。

```js
console.log(true + 1); // 2
console.log(false + 1); // 1
```

### （4）undefined 和 null

```js
//defined未定义
var variable = undefined;
console.log(variable + "pink"); //undefinedpink
console.log(variable + 1); //NaN  undefined和数字相加，最后结果是NaN，非数值
console.log(variable + true); //NaN

//null空值
var space = null;
console.log(space + "pink"); //nullpink
console.log(space + 1); //1
```

## 3.3 获取变量数据类型

**（1）typeof 可用来获取检测变量的数据类型**

```js
var num = 18;
console.log(typeof num); // 结果 number
var str = 'pink';
console.log(typeof str); //string
var flag = true;
console.log(typeof flag); //boolean
var vari = undefined;
console.log(typeof vari); //undefined
bar timer = null;
console.log(typeof timer); //object

//prompt 取过来的值是字符型的 ***
var age = prompt('请输入你的年龄')；
console.log(age);
console.log(typeof age); //string
```

在浏览器控制台中，可以根据颜色判断属于什么数据类型

- 紫色-数字类型、黑色-字符串型、蓝色-布尔型、灰色-undefined 和 null 型

**（2）字面量**

字面量是在源代码中一个固定值的表示法。

- 数字字面量：8, 9, 10
- 字符串字面量：'xxx', "xxx"
- 布尔字面量：true，false

## 3.4 数据类型转换

就是把一种数据类型的变量转换成另外一种数据类型。

通常会实现 3 种方式的转换：

**（1）转换为字符串类型**

| 方式                              | 说明                         |
| --------------------------------- | ---------------------------- |
| toString()                        | 转成字符串                   |
| String()                          | 转成字符串                   |
| **加号拼接字符串** （隐形式转换） | 和字符串拼接的结果都是字符串 |

```js
var num = 10;
// 1.把数字型转换为字符串型 变量.toString()
console.log(num.toString());

// 2.利用String(变量)
console.log(String(str));

// 3.利用 + 拼接字符串的方法实现转换效果
console.log(num + "");
```

**（2）转换为数字型**

| 方式                   | 说明                               | 案例                      |
| ---------------------- | ---------------------------------- | ------------------------- |
| parseInt(string)函数   | 将 string 类型转换成**整数**数值型 | parseInt('78')            |
| parseFloat(string)函数 | 将 string 类型转成浮点数数值型     | parseFloat('78.21')       |
| Number()强制转换函数   | 将 string 类型转换为数值型         | Number('12')              |
| js 隐式转换(- \* /)    | 利用算术运算隐式转换为数值型       | '12' - 0 或者 '12' - '10' |

- 注意 parseInt 和 parseFloat 单词的大小写
- 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型

```js
console.log(parseInt("3.14")); //3取整
console.log(parseInt("3.94")); //3
console.log(parseInt("120px")); //120,会去掉单位  转换为浮点数也一样
console.log(parseInt("rem120px")); //NaN  转换为浮点数也一样
```

```js
<script>
  var num1 = prompt('输入第一个值：'); var num2 = prompt('输入第二个值：');
  //要转为数字型才可以相加 var result = parseFloat(num2) + parseFloat(num1);
  alert('你的结果是：' + result);
</script>
```

**（3）转换为布尔型**

| 方式          | 说明               | 案例             |
| ------------- | ------------------ | ---------------- |
| Boolean()函数 | 其他类型转成布尔值 | Boolean('true'); |

- 代表**空**、**否定的值**会被转换为 false ，如 ''、0、NaN、null、undefined
- 其余值都会被转换为 true

# 4. 运算符

运算符也称操作符，适用于实现负值、比较和执行算术运算等功能的符号。

JavaScript 中常用运算符有：算数运算符、递增运算符和递减运算符、比较运算符、逻辑运算符、赋值运算符。

## 4.1 算数运算符

概念：算术运算使用的符号，用于执行两个变量或值得算数运算。

| 运算符 | 描述           | 实例                 |
| ------ | -------------- | -------------------- |
| +      | 加             | 10+20=30             |
| -      | 减             | 10-20=-10            |
| \*     | 乘             | 10\*20=200           |
| /      | 除             | 10/20=0.5            |
| %      | 取余数（取模） | 返回除法的余数 9%2=1 |

注：

- 避免直接用浮点数（小数）进行运算；不能之间判断两个浮点数是否相等。（因为会先转换为二进制运算）

- %取余为 0，可以用于判断能否被整除。
- 算数运算符也有优先级。

**（1）表达式和返回值**

- 表达式是由数字、运算符、变量等组成的式子。

- 表达式最终都会有一个结果，即返回值

## 4.2 递增和递减运算符

可以使用递增（++）和递减（--）运算符来完成。

```js
var num = 1;
num++; //num = num + 1;
```

在 JavaScript 中，递增（++）和递减（--）既可以放在变量面前，也可以放在变量后面。放在变量前，称为前置递增（递减）运算符；放在变量后面，称为后置递增（递减）运算符。

注：递增和递减运算符**必须**和**变量**配合使用。

- 前置自增和后置自增，如果**单独使用**，效果是一样的

- 否则，与其他代码连用，遵循：

  前置自增：先自加，后返回值； //返回值也加了

  后置自增：先返回值，后自加。 //先表达式返回原值，后面变量再加 1。（表达式即 x++）

大部分是使用的自增是后置递增（递减），并且代码独占一行。

```js
var age = 10;
console.log(++age + 10); //21
console.log(age++ + 10); //20
```

例子：

```js
var a = 10;
++a; //a=11，++a为11
var b = ++a + 2; //a=12，++a为12
console.log(b); //14

var c = 10;
c++; //c=11,c++为11  因为单独使用
var d = c++ + 2; //c++为11，c=12
console.log(d); //13

var e = 10;
var f = e++ + ++e; //e++为10，e=11；e=12,++e为12
console.log(f); //22
```

## 4.3 比较运算符

概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，会返回一个布尔值（true/false）作为比较运算的结果。

| 运算符名称  | 说明                                                       | 案例      | 结果  |
| ----------- | ---------------------------------------------------------- | --------- | ----- |
| <           | 小于号                                                     | 1<2       | true  |
| >           | 大于号                                                     | 1>2       | false |
| >=          | 大于等于号（大于或者等于）                                 | 2>=2      | true  |
| <=          | 小于等于号（小于或者等于）                                 | 3<=2      | false |
| ==          | 判等号（默认转换数据类型，会把字符串型的数据转换为数字型） | 37==37    | true  |
| !=          | 不等号                                                     | 37!=37    | false |
| `===` `!==` | 全等 ，要求值和数据类型都一样                              | 37==='37' | false |

```js
console.log(3 >= 5); //false
console.log(3 == 5); //false
console.log(17 == "17"); //true
```

**=小结：**

| 符号 | 作用 | 用法                                     |
| ---- | ---- | ---------------------------------------- |
| =    | 赋值 | 把右边给左边                             |
| ==   | 判断 | 判断两边值是否相等（注意此时有隐式转换） |
| ===  | 全等 | 判断两边的值和数据类型是否完全相同       |

## 4.4 逻辑运算符

**（1）用布尔值参与的逻辑运算**

概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值，后面开发常用于多个条件的判断。

| 逻辑运算符 | 说明                   | 案例            |
| ---------- | ---------------------- | --------------- |
| &&         | “逻辑与”，简称“与” and | true && false   |
| \|\|       | “逻辑或”，简称“或” or  | true \|\| false |
| ！         | “逻辑非”，简称“非” not | ! true          |

- 逻辑与&&

  两边都是 true 才返回 true，否则返回 false

- 逻辑或 ||

  两边都为 false 才返回 false，否则都为 true

- 逻辑非 ！

  逻辑非（!）也叫作取反符，如 true 的相反值是 false

**（2）短路运算（逻辑中断）-- 表达式参与逻辑运算**

短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时，就**<u>不再继续运算</u>**右边的表达式的值；

- 逻辑与

语法： 表达式 1 && 表达式 2

如果第一个表达式的值为真，则返回表达式 2
如果第一个表达式的值为假，则返回表达式 1

```js
//代表空、否定的值会被转换为false ，如 ''、0、NaN、null、undefined
console.log(123 && 456); // 456
console.log(0 && 456); // 0
console.log(123 && 456 && 789); // 789
```

- 逻辑或

  语法： 表达式 1 || 表达式 2
  如果第一个表达式的值为真，则返回表达式 1
  如果第一个表达式的值为假，则返回表达式 2

例子：

```js
var num = 0;
console.log(123 || num++); //逻辑中断，逻辑或 输出123，即不再执行表达式2，故num为0
console.log(num);
```

## 4.5 赋值运算符

概念：用来把数据赋值给变量的运算符。

| 赋值运算符  | 说明                  | 案例                                               |
| ----------- | --------------------- | -------------------------------------------------- |
| =           | 直接赋值              | var userName = '我是值'；                          |
| +=、-=      | 加、减一个数 后再赋值 | var age = 10; age += 5; //15，相当于 age = age +5; |
| \*=、/=、%= | 乘、除、取模 后再赋值 | var age = 2; age \*= 5; //10                       |

## 4.6 运算符优先级

| 优先级 | 运算符     | 顺序            |
| ------ | ---------- | --------------- |
| 1      | 小括号     | ()              |
| 2      | 一元运算符 | ++ -- ！        |
| 3      | 算术运算符 | 先\* / % 后+ -  |
| 4      | 关系运算符 | > >= < <=       |
| 5      | 相等运算符 | == != `===` !== |
| 6      | 逻辑运算符 | 先&&后\|\|      |
| 7      | 赋值运算符 | =               |
| 8      | 逗号运算符 | ，              |

- 一元运算符里面的逻辑非优先级很高
- 逻辑与比逻辑或优先级高

```js
// 运算方法，先把最低级划分出来，接着运算最低级左右两边式子
console.log( 4 >= 6 || '人' != '阿凡达' && !(12 * 2 == 144) && true); // || && &&
var num = 10;
console.log( 5 == num / 2 && (2 + 2 * num).toString() === ‘22’)； // &&
```

# 5. JavaScript 流程控制-分支

流程控制就是来控制我们的代码按照什么结构顺序来执行

流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构。

<img src="images\图片1.png" style="zoom: 67%;" />

## 5.1 顺序流程控制

程序会按照代码的先后顺序，依次执行。程序中大多数的代码都是这样执行。

## 5.2 分支流程控制

根据不同的条件，执行不同的路径代码，从而得到不同的结果。

js 语言提供了两种分支结构语句：if 语句、 switch 语句

### 5.2.1 if 语句

**（1）if 语句**

- 语法结构：

```js
if (条件表达式) {
  //执行语句;
}
```

- 执行思路：

如果 if 里面的条件表达式结果为真 true，则执行大括号里面的执行语句；

如果 if 条件表达式为假 flase，则不执行大括号里面的语句，则执行 if 语句后面的代码。

##### 案例 进入网吧

**（2）if else 语句（双分支语句）**

- 语法结构：

```js
if (条件表达式) {
  //执行语句1;
} else {
  //执行语句2;
}
```

- 执行思路：

如果表达式结果为真，那么执行语句 1，否则 执行语句 2。 2 选 1

- 注：

if 里面的语句 1 和 else 里面的语句 2，最终只能执行一个语句；

else 后面直接跟大括号。

##### 案例 判断闰年

（能够被 4 整除且整除 100 为闰年，或者能够被 400 整除的就是闰年）

**（3）if else if 语句（多分支语句）**

利用多个条件来选择不同的语句执行，得到不同的结果。

```js
if (条件表达式1) {
  //语句1;
} else if (条件表达式2) {
  //语句2;
} else if (条件表达式3) {
  //语句3;
} else {
  //最后的语句;
}
```

- 执行思路：

如果表达式 1 满足，那么执行语句 1，执行完毕后退出整个 if 分支语句；

如果条件表达式 1 不满足，则判断表达式 2，满足执行语句 2，以此类推；

如果表达式都不成立，则执行 else 里的语句。

- 注：

多分支语句是多选 1，最后只能有一个语句执行

else if 里面的条件理论上可以任意多个

else if 中间有空格

### 5.2.2 switch 语句

switch 语句也是多分支语句。

- 语法结构：

```js
//switch 转换、开关，case小例子或者选项的意思
switch(表达式) {
    case value1:
        执行语句1;
        break;
    case value2:
        执行语句2;
        break;
    ...
    default:
        执行最后的语句;
}
```

- 执行：

如果表达式的值和 case 后面的选项值相匹配，匹配上就执行 case 里面的语句，否则执行 default 里的语句。

- 注意：

开发里面，表达式经常写成变量；

switch() 括号里面的值和 case 里面的值相匹配的时候是全等，必须是值和数据类型都一致才可以 ===；

break 如果当前的 case 里面没有 break，则不会退出 switch 是继续执行下一个 case，不管 switch()是否匹配。

---

**switch 语句和 if else if 语句的区别**

- 一般情况下，它们两个语句可以相互替换
- switch...case 语句通常处理 case 为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围)
- switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而 if…else 语句有几种条件，就得判断多少次
- 当<u>分支比较少</u>时，if… else 语句的执行效率比 switch 语句高
- 当<u>分支比较多</u>时，switch 语句的执行效率比较高，而且结构更清晰

### 5.2.3 三元表达式

有三元运算符组成的式子，称为三元表达式。

- 语法结构：

```js
条件表达式 ? 表达式1 : 表达式2; //简化版的if else 语句
```

- 执行：

如果条件表达式结果为真，则返回表达式 1 的值，否则返回表达式 2 的值。

## 5.3 循环流程控制

循环的目的：可以重复循环某些语句。

### 5.3.1 for 循环

for 重复循环某些代码，通常跟计数有关系

- 语法结构：

```js
for (初始化变量; 条件表达式; 操作表达式) {
  //循环体
}
// 初始化变量 就是var声明的一个普通变量，通常用于作为计数器使用
// 条件表达式 就是用来决定每一次循环是否继续执行，就是终止的条件
// 操作表达式 就是每次循环最后执行的代码，经常用于我们计数器变量进行更新（递增或者递减）
```

案例：

```js
for (var i = 1; i <= 100; i++) {
  console.log("你好");
}
```

##### 断点调试

- 断点调试可以帮我们观察程序的运行过程
- 浏览器中按 F12（检查）--> sources -->找到需要调试的文件-->在程序的某一行设置断点-->刷新
- Watch: 监视，通过 watch 可以监视变量的值的变化，非常的常用。
- F11: 程序单步执行，让程序一行一行的执行，这个时候，观察 watch 中变量的值的变化。

**for 循环重复相同的代码**

```js
//让用户控制输出的次数
var num = prompt('请输入次数:')；
for ( var i = 1 ; i <= num; i++) {
    console.log('你好');
}
```

**for 循环重复不同的代码**

主要是因为使用了计数器 ，计数器在每次循环过程中都会有变化。

```js
//求输出一个人1到100岁
for (var i = 1; i <= 100; i++) {
  if (i == 1) {
    console.log("是的，这个人今年1岁了");
  } else if (i == 100) {
    console.log("是的，这个人今年100岁了");
  } else {
    console.log("这个人今年" + i + "岁了");
  }
}
```

### 5.3.2 双重 for 循环

- 语法结构：

```js
for (外循环的初始; 外循环的条件; 外循环的操作表达式) {
  for (内循环的初始; 内循环的条件; 内循环的操作表达式) {
    //执行语句;
  }
}
//外层循环一次，里面的循环执行全部
```

```js
for (var i = 1; i <= 3; i++) {
  console.log("外层循环" + i + "次");
  for (var j = 1; j <= 3; j++) {
    console.log("里层循环" + j + "次");
  }
}
```

### 5.3.3 while 循环

- 语法结构：

```js
while (条件表达式) {
  // 循环体代码
}
```

- 执行：

先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码

例子：

```js
var num = 1;
while (num < 100) {
  console.log("你好");
  num++;
}
```

- 注意：

使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环；

while 循环和 for 循环的不同之处在于 while 循环可以做较为复杂的条件判断，比如判断用户名和密码。

例子：

```js
var message = prompt("你好");
while (message !== "你好") {
  message = prompt("你好");
}
```

### 5.3.4 do while 循环

- 语法结构：

```js
do {
  // 循环体代码 - 条件表达式为 true 时重复执行循环体代码
} while (条件表达式);
```

- 执行：

先执行一次循环体代码；

再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码

- 注意：

先执行循环体，再判断，do…while 循环语句<u>至少会执行一次</u>循环体代码

例子：

```js
do {
  var message = prompt("你好");
} while (message !== "你好");
alert("hello");
```

**循环小结：**

- 果是用来计次数，跟数字相关的，三者使用基本相同，但更建议使用 for 循环语句
- while 和 do…while 可以做更复杂的判断条件，比 for 循环灵活一些
- while 和 do…while 执行顺序不一样，while 先判断后执行，do…while 先执行一次，再判断执行
- while 和 do…while 执行次数不一样，do…while 至少会执行一次循环体， 而 while 可能一次也不执行

### 5.3.5 continue break

**（1）continue 关键字**

continue 关键字用于立即跳出本次循环，继续下一次循环。

例子：

```js
for (var i = 1; i <= 5; i++) {
  if (i == 3) {
    console.log("xxx");
    continue; // 跳出本次循环，跳出的是第3次循环
  }
  console.log("yy" + i + "yy");
}
```

**（2）break 关键字**

break 关键字用于立即跳出整个循环（循环结束）。

例子：

```js
for (var i = 1; i <= 5; i++) {
  if (i == 3) {
    break; // 直接退出整个for 循环，跳到整个for下面的语句
  }
  console.log("yy" + i + "yy");
}
```

# 6. JavaScript 数组

数组(Array)可以把一组相关的数据一起存放，并提供方便的访问(获取）方式

概念：数组是指一组数据的集合，可以将一组数据存储在单个变量名下

```js
// 普通变量一次只能存储一个值
var num = 10;
// 数组一次可以存储多个值
var arr = [1, 2, 3, 4, 5];
```

## 6.1 创建数组

**（1）利用 new 创建数组**

```js
var 数组名 = new Array() ；
var arr = new Array();   // 创建一个新的空数组
```

- 注意 Array () ，A 要大写

**（2）利用数组字面量创建数组**

```js
//1. 使用数组字面量[]方式创建空的数组
var  数组名 = []；
//2. 使用数组字面量方式创建带初始值的数组
var  数组名 = ['xx', 12];  //'xx',12 称为数组元素
```

- 数组的字面量是方括号 [ ] ，
- 数组里面存放的称为数组元素，数组元素的类型不限制
- 声明数组并赋值称为数组的初始化
- 数组字面量方式使用最多

## 6.2 获取数组元素

**（1）数组的索引**

**索引 (下标) ：**用来访问数组元素的序号（数组下标<u>从 0 开始</u>）

- 获取数组元素：格式 `数组名[索引号]`
- 若没有这个数组元素，会输出 undefined

## 6.3 遍历数组

怎么样将数组中的全部元素取出来？--> 循环

**（1）遍历**

**遍历:** 就是把数组中的每个元素从头到尾都访问一次

```js
//数组索引号是从0开始，所以i必须从0开始
//输出的时候 arr[i] i是计数器，当索引号使用
var arr = ["red", "green", "blue"];
for (var i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

**（2）数组的长度**

使用`数组名.length`可以访问数组元素的数量（数组长度）。

注意：

- 数组的长度是数组元素的个数 ，不要索引号混淆
- 数组的长度 ，动态监测数组元素的个数

- arr[i] 不是计算器 i

## 6.4 数组中新增元素

**（1）通过修改 length 长度新增数组元素**

- 可以通过修改 length 长度来实现数组扩容的目的
- length 属性是可读写的

```js
var arr = ["red", "green", "blue"];
arr.length = 5;
console.log(arr);
console.log(arr[4]); //undefined
console.log(arr[5]); //undefined
//索引号是 4，5 的空间没有给值，就是声明变量未给值，默认值就是 undefined
```

**（2）通过修改数组索引新增数组元素**

- 通过此方法，可以追加数组元素
- 可以替换原来的数组元素，因此不能直接给数组名赋值，否则会覆盖掉以前的数据

```js
var arr = ["red", "green", "blue", "pink"];
arr[4] = "hotpink";
console.log(arr);
```

##### 数组排序（冒泡排序）

冒泡排序：是一种算法，把一系列的数据按照一定的顺序进行排列显示(从小到大或从大到小）。

```js
var arr = [5, 4, 3, 2, 1];
for (var i = 0; i < arr.length - 1; i++) {
  //外层循环管趟数
  for (var j = 0; j < arr.length - i - 1; j++) {
    //里面的循环管每一趟的交换次数
    //内部交换2个变量
    if (arr[j] > arr[j + 1]) {
      var temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
console.log(arr);
```

# 7. JavaScript 函数

**函数：**就是封装了一段可被重复调用执行的代码块。

作用：通过此代码块可以实现大量代码的重复使用。

例子：

```js
//计算num1-num2的和
function getSum(num1, num2) {
  var sum = 0;
  for (var i = num1; i <= num2; i++) {
    sum += i;
  }
  console.log(sum);
}
getSum(1, 100);
getSum(10, 50);
getSum(1, 10);
```

## 7.1 函数的使用

函数在使用时分为两步：声明函数和调用函数。

**（1）声明函数**

```js
// 声明函数
function 函数名() {
  //函数体代码
}
```

- function 是声明函数的关键字，必须小写
- 函数是做某件事，函数名一般是动词，如 getSum
- 函数不调用自己不执行

**（2）函数调用**

```js
// 调用函数
函数名(); // 通过调用函数名来执行函数体代码
```

- 调用的时候千万不要忘记添加小括号
- 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

**（3）函数的封装**

函数的封装是把一个或者多个功能通过函数的方式封装起来。（类似快递打包）

## 7.2 函数的参数

可以利用函数的参数实现函数重复不同的代码。

**（1）形参和实参**

```js
function 函数名(形参1,形参2...) { //在声明函数的小括号里面是 形参 （形式上的参数）
    //函数体代码
}

函数名(实参1,实参2...); //在函数调用的小括号里面是实参 （实际的参数）
```

**（2）函数参数的传递过程**

- 形参是接收实参的（实参是传递给形参的），类似于一个不用声明的变量
- 函数的参数可以有也可以没有，个数不限
- 实参和形参的多个参数之间用逗号,分隔

**（3）函数形参和实参个数不匹配问题**

函数形参和实参个数可以不匹配，但不建议。

| 参数个数             | 说明                                 |
| -------------------- | ------------------------------------ |
| 实参个数等于形参个数 | 输出正确结果                         |
| 实参个数大于形参个数 | 只取到形参的个数                     |
| 实参个数小于形参个数 | 多的形参定义为 undefined，结果为 NaN |

注意：在 JavaScript 中，形参的默认值是 undefined。

## 7.3 函数的返回值

**（1）return 语句**

```js
// 声明函数
function 函数名（）{
    ...
    return  需要返回的值；
}
// 调用函数
函数名();    // 此时调用函数就可以得到函数体内return 后面的值
```

- 函数只是实现某种功能，最终的结果需要返回给函数的调用者，即函数名()，通过 return 实现的
- 只要函数遇到 return，就把后面的结果（值），返回给函数的调用者， 相当于 函数名() = return 后面的结果

例子：

```js
function getResult() {
  return 666;
}
//getResult();  其中，getResult()  =  666
console.log(getResult());
```

**（2）return 终止函数**

- return 语句之后的代码不被执行。

- return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准。

例子：

```js
function getResult(num1, num2) {
  return [num1 + num2, num1 - num2, num1 * num2, num1 / num2];
}
//在我们实际开发里面，经常使用一个变量来接收函数的返回结果，使用更简单
var re = getResult(1, 3); //返回的是一个数组
console.log(re);
```

**（3）函数没有 return ，返回 undefined**

函数都是有返回值的

- 如果有 return ，则返回 return 后面的值
- 如果没有 return ，则返回 undefined

**（4）break ,continue ,return 的区别**

- break ：结束当前的循环体（如 for、while）
- continue ：跳出本次循环，继续执行下次循环（如 for、while）
- return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码

## 7.4 arguments 的使用

**当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。**

在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。

所有函数都内置了一个 arguments 对象，arguments 对象中<u>存储了传递的**所有实参**</u>。

---

- arguments 展示形式是一个伪数组，因此可以进行遍历。

- **伪数组**具有以下特点：

  - 具有 length 属性（arguments.length）
  - 按索引方式储存数据
  - 不具有数组的 push , pop 等方法

- 只有函数才有 arguments 对象，而且每个函数都内置好了这个 arguments

## 7.5 函数可以调用另外一个函数

```js
function fn1() {
  console.log(111);
  fn2();
  console.log("fn1");
}
function fn2() {
  console.log(222);
  console.log("fn2");
}
fn1();
// 输出的结果是:
111;
222;
fn2;
fn1;
```

## 7.6 函数的两种声明方式

- 利用函数关键字自定义函数（命名函数）
- 函数表达式（匿名函数）

```js
//1.利用函数关键字自定义函数（命名函数）
function fn() {
    ...
}
fn();
//调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面


//2.函数表达式（匿名函数）
//var fun = function() {...};
var fun = function() {
    console.log('函数表达式');
}
fun();
//调用的方式，函数调用必须写到函数体下面
//fun是变量名，不是函数名，fun里面存储的是一个函数
//函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存的是函数

var fun = function(aru) {
    console.log('函数表达式');
    console.log(aru);
}
fun('xxx');
//函数表达式也可以进行传递参数
```

# 8. JavaScript 作用域

JavaScript 作用域：代码名字（变量）在某个范围内起作用和效果，目的是增强了程序的可靠性，减少了名字冲突。

JavaScript（es6 前）中的作用域有两种：全局作用域、局部作用域（函数作用域）

**（1）全局作用域**

全局作用域：整个 script 标签，或者是一个单独的 js 文件。

**（2）局部作用域**

局部作用域（函数作用域）：在函数内部就是局部作用域，这个代码的名字只在函数内部起效果和作用

```js
//全局作用域
var num = 10;
console.log(num);

//局部作用域
function fn() {
  var num = 20;
  console.log(num);
}

//全局和局部的作用域中的num互不影响，不冲突
```

**（3）JS 没有块级作用域（在 ES6 之前）**

- 块作用域由 { } 包括
- 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用

## 8.1 变量的作用域

在 JavaScript 中，根据作用域的不同，变量可以分为两种：全局变量、局部变量

**（1）全局变量**

在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）

- 全局变量在代码的任何位置都可以使用（包括函数内部）
- 在全局作用域下 var 声明的变量 是全局变量
- <u>特殊情况下</u>，在函数内不使用 var 声明的变量也是全局变量（不建议使用）

---

**（2）局部变量**

在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）

- 局部变量只能在该函数内部使用
- 在函数内部 var 声明的变量是局部变量
- 函数的<u>形参</u>实际上就是局部变量

---

**（3）全局变量和局部变量的区别**

- 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
- 局部变量：只在函数内部使用，当代码块运行结束后，就会被销毁，因此更节省内存空间

## 8.2 作用域链

- 只要是代码，就至少有一个作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
- 根据在内部函数可以访问外部函数变量的这种机制，用<u>链式查找</u>（就近原则）决定哪些数据能被内部函数访问，就称作用域链。

例子：

```js
function f1() {
  var num = 123;
  function f2() {
    console.log(num); //就近原则，站在目标出发，一层一层的往外查找
  }
  f2();
}
var num = 456;
f1();
//结果 123
```

# 9. JavaScript 预解析

（1）JavaScript 解析器在运行 JavaScript 代码的时候分为两步：**预解析**和**代码执行**。

- 预解析：js 引擎会把 js 里面所有的 var 还有 function 提升到当前作用域的最前面
- 代码执行：按照代码书写的顺序从上往下执行

---

（2）预解析分为 **变量预解析（变量提升）**和 **函数预解析（函数提升）**

- 变量提升：就是把所有的变量声明提升到<u>当前的作用域</u>最前面， 不提升变量的赋值操作

- 函数提升：就是把所有的函数声明提升到<u>当前作用域</u>的最前面， 不调用函数

**作用域包括：全局作用域和局部作用域。**

例子：

```js
//变量提升例1
console.log(num);
var num = 10;
//相当于执行了以下代码：
var num;
console.log(num); //输出结果 undefined
```

```js
//变量提升例2
fun();
var fun = function () {
  console.log(22);
};
//相当于执行了以下代码：
var fun;
fun();
fun = function () {
  console.log(22);
}; //结果 报错
// 因此，函数表达式的调用，必须写在函数下面
```

```js
//函数提升
fn();
function fn() {
  console.log("打印");
}
//相当于执行了以下代码：
function fn() {
  console.log("打印");
}
fn(); //输出结果 打印
```

---

案例：

```js
var num = 10;
fun();
function fun() {
  console.log(num);
  var num = 20;
}
//相当于执行以下：
var num；
function fun() {
    var num;
    console.log(num);
    //输出结果:undefined 就近原则，按从上往下的顺序执行，因此是var num，而不是num=20
    num = 20;
}
num = 10;
fun();
```

# 10. JavaScript 对象

对象：对象是一个<u>具体的</u>事物。

在 JavaScript 中，对象是一组无序的相关<u>属性</u>和<u>方法</u>的集合。

## 10.1 创建对象的方式

在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）：

利用字面量创建对象 、利用 new Object 创建对象 、利用构造函数创建对象

**（1）利用字面量创建对象**

对象字面量：就是花括号 { }

- 里面的属性或者方法，采用键值对的形式。` 键 属性名 : 值 属性值`（值，可以是是任意类型的值，比如数字类型、字符串类型...）
- 多个属性或者方法中间用逗号隔开
- 方法冒号后面跟的是一个匿名函数

```js
//var obj = {}; 创建了一个空对象
var obj = {
  name: "pink",
  age: 18,
  sex: "男",
  sayHi: function () {
    console.log("大家好啊~");
  },
};
```

**对象的调用：**

- 对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”
- 对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号
- 对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号

**变量、属性、函数、方法总结：**

```js
//变量和属性的相同：他们都是用来存储数据的
//函数和方法的相同点：都是事先某种功能，做某件事
var num = 10;
var obj = {
    age = 18;
    fn: function() {
        ...
    }
}
function fn() {
    ...
}
console.log(obj.age);
//变量：单独声明赋值，单独存在。使用的时候直接写变量名
//属性：对象里面的变量称为属性，不需要声明。使用的时候必须是 对象.属性 或者 对象['属性']
//函数：单独存在的，通过“函数名()”的方式就可以调用
//方法：在对象里面，方法不需要声明，使用“对象.方法名()”的方式就可以调用
```

---

**（2）利用 new Object 创建对象**

- 使用的格式：对象.属性 = 值;
- 每个属性和方法之间用 分号结束

```js
var obj = new Object(); //创建一个空的对象
obj.name = "pink";
obj.age = 18;
obj.sex = "男";
obj.sayHi = function () {
  console.log("hi~");
};
```

**对象的调用：**

同上

---

**（3）利用构造函数创建对象 **

前面两种创建对象的方式一次只能创建一个对象，因此可以利用函数的方法，重复使用这些相同的代码，称为构造函数，里面封装的不是普通代码，而是对象。

##### 构造函数

就是把对象里面的一些相同的属性和方法抽取出来，然后封装到这个函数里面。

- 构造函数用于创建某一类对象，其首字母要大写
- 构造函数必须使用 new 来调用！

- 构造函数不需要 return，就可以返回结果

- 只要`new 构造函数名()` 调用函数就创建一个对象

```js
//构造函数的语法格式：
function 构造函数名() {
    this.属性 = 值;
    this.方法 = function() {...}
}
//调用
new 构造函数名()；//调用函数返回的是对象object
```

- 构造函数：如 Stars()，泛指某一大类
- 对象：特指，是一个具体的食物
- 利用构造函数创建对象的过程，也称为**对象的实例化**

## 10.2 new 关键字

new 执行：

- 在内存中创建一个新的空对象。
- 让 this 指向这个新的对象。
- 执行构造函数里面的代码，给这个新对象<u>添加属性和方法</u>。
- 返回这个新对象（所以构造函数里面不需要 return）

## 10.3 遍历对象属性

本质：对象就是一组无序的相关属性和方法的集合。因此不可以用 for 循环的方法

`for...in `语句用于对数组或者对象的属性进行循环操作。

语法：

```js
for (变量 in 对象名字) {
  // 在此执行代码
}
for (var k in obj) {
  console.log(k); // k是变量，输出的是 属性名
  console.log(obj[k]); // obj[k]输出的是，属性值
}
```

- 命名规范：通常 for in 里面的变量写为 k 或者 key。

# 11. JavaScript 内置对象

JavaScript 中的对象分为 3 种：自定义对象 、内置对象、 浏览器对象。

前面两种对象属于 ECMAScript；第三个浏览器对象属于我们 JS 独有的

**内置对象：**就是指 JS 语言自带的一些对象，这些对象供开发者使用。比如，Math、 Date 、Array、String 等

## 11.2 查文档

**（1）MDN**

通过文档查看内置对象中方法的使用。 [MDN 网址](https://developer.mozilla.org/zh-CN/)

**（2）学习对象中的方法**

- 查阅该方法的功能
- 查看里面参数的意义和类型
- 查看返回值的意义和类型
- 进行测试

## 11.3 Math 对象

Math 对象：不是一个构造函数，所以不需要 new 来调用，而是直接使用里面的属性和方法即可

```js
Math.PI; // 圆周率
Math.floor(); // 向下取整，如1.9为1
Math.ceil(); // 向上取整，如1.1为2
Math.round(); // 四舍五入版 就近取整   注意 -3.5   结果是  -3 ，向上取
Math.abs(); // 绝对值，可以隐式转换，把字符串型'2'转为数字型2；'文字'输出NaN
Math.max() / Math.min(); // 求最大和最小值
```

## 11.4 随机数方法 random()

random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 <= x < 1 ;

这个方法里面不跟参数。

例子：

```js
//得到一个两数之间的随机整数，包括两个数在内，  Math.floor(Math.random() * (max - min + 1)) + min;
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
```

## 11.5 日期对象

Date：是一个构造函数，所以我们需要实例化后才能使用，必须要 new 调用；

Date 实例用来处理日期和时间

**（1）Date()方法的使用**

```js
//Date() 日期对象，是一个构造函数，必须使用new来调用创建我们的日起对象
var arr = new Array(); //创建一个数组对象
var obj = new Object(); //创建了一个对象实例

// 1.使用Date 如果没有参数，返回当前系统的当前时间
var date = new Date();
console.log(date);
// 2.参数常用的写法 数字型 2019,10,2  或者是 字符串型 '2019-10-1 8:8：8'
var date1 = new Date(2019, 10, 2);
console.log(date1); //返回的是11月，不是10月  字符串写法不会
```

**（2）日期格式化**

| 方法名        | 说明                          | 代码                     |
| ------------- | ----------------------------- | ------------------------ |
| getFullYear() | 获取当年                      | 构造函数名.getFullYear() |
| getMonth()    | 获取当月（0-11，月份要加 1）  | 构造函数名.getMonth()    |
| getDate()     | 获取当天是日期                | 构造函数名.getDate()     |
| getDay()      | 获取星期几（周日 0 到周六 6） | 构造函数名.getDay()      |
| getHours()    | 获取当前小时                  | 构造函数名.getHours()    |
| getMinutes()  | 获取当前分钟                  | 构造函数名.getMinutes()  |
| getSeconds()  | 获取当前秒钟                  | 构造函数名.getSeconds()  |

例子：

```js
//输出今天是 年 月 日 星期几
var date = new Date(); //对象实例化
var year = date.getFullYear();
var month = date.getMonth();
var dates = date.getDate();
var arr = [
  "星期日",
  "星期一",
  "星期二",
  "星期三",
  "星期四",
  "星期五",
  "星期六",
];
var day = date.getDay();
console.log("今天是" + year + "年" + month + "月" + dates + "日 " + arr[day]);
```

**（3）获取日期的总的毫秒形式**

Date 对象是基于 1970 年 1 月 1 日（世界标准时间）起的毫秒数（时间戳）；

```js
//通过valueOf()、getTime()获取  现在时间距离1970-1-1总的毫秒数
console.log(valueOf());
console.log(getTime());
```

简单写法：

```js
//写法一：（最常用）
var date = +new Date(); //+new Date() 返回的就是总的毫秒数
console.log(date);

//写法二： H5 新增的获取总的毫秒数
console.log(Date.now());
```

## 11.6 数组对象

**（1）创建数组对象**

创建数组对象的两种方式：

- 字面量方式

如：`var arr = [1,2,3];`

- new Array()

`var arr = new Arry(2); //这个2表示数组的长度为2，里面有2个空的数组元素`

`var arr = new Arry(2,3); //等价于[2,3] 这样写表示里面有两个数组元素 为2,3`

**（2）检测是否为数组**

- 法一：instanceof 运算符

```js
var arr = [];
var obj = {};
console.log(arr instanceof Arry); //true
console.log(obj instanceof Arry); //false
```

- 法二：Array.isArray(参数);

```js
//H5新增的方法 ie9以上版本支持
var arr = [];
var obj = {};
console.log(Array.isArray(arr)); //true
console.log(Array.isArray(obj)); //false
console.log(Array.isArray([1, 2, 3])); //true
```

Array.isArray 优先于 instanceof，因为前者能监测 iframes。

**（3）添加删除数组元素的方法**

| 方法名            | 说明                                                                | 返回值               |
| ----------------- | ------------------------------------------------------------------- | -------------------- |
| push(参数 1...)   | 末位添加一个或多个元素，注意修改原数组                              | 并返回新的长度       |
| unshift(参数 1..) | 开头添加一个或多个元素，注意修改原数组                              | 并返回新的长度       |
| pop()             | 删除数组最后一个元素，把数组长度减 1；<br/>没有参数、修改原来的数组 | 返回它删除的元素的值 |
| shift()           | 删除数组第一个元素，把数组长度减 1；<br/>没有参数、修改原来的数组   | 返回它删除的元素的值 |

用法：

```js
var arr = [1, 2, 3];
console.log(arr.push(4, "red")); //5
console.log(arr); //[1,2,3,4,'red']
```

**（4）数组排序**

| 方法名    | 说明                         | 是否修改原来数组                     |
| --------- | ---------------------------- | ------------------------------------ |
| reserve() | 颠倒数组中元素的顺序，无参数 | 该方法会改变原来的数组，返回新的数组 |
| sort()    | 对数组的元素进行排序         | 该方法会改变原来的数组，返回新的数组 |

```js
// 1.翻转数组
var arr = ["pink", "blue", "red"];
arr.reverse();
console.log(arr);
```

```js
// 2.数组排序（冒泡排序）
var arr = [2, 4, 6, 1];
arr.sort(); //此时没有写参数，只适用于个位数排序
console.log(arr);

//完整写法：
var arr = [12, 45, 2, 4];
arr.sort(function (a, b) {
  return a - b; //升序排序
  // return b-a; //降序排序
});
console.log(arr);
```

**（5）数组索引方法**

| 方法名        | 说明                               | 返回值                                 |
| ------------- | ---------------------------------- | -------------------------------------- |
| indexOf()     | 数组中查找满足条件的第一个的索引   | 如果存在，返回索引号；不存在，则返回-1 |
| lastIndexOf() | 数组中查找满足条件的最后一个的索引 | 如果存在，返回索引号；不存在，则返回-1 |

##### 数组去重

```js
//重点
function unique(arr) {
  var newArr = []; //新数组
  for (var i = 0; i < arr.length; i++) {
    if (newArr.indexOf(arr[i]) === -1) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
console.log(unique(["blue", "blue", "red", "green"]));
//输出['blue', 'red', 'green']
```

**（6）数组转换为字符串**

| 方法名         | 说明                                             | 返回值         |
| -------------- | ------------------------------------------------ | -------------- |
| toString()     | 把数组转换成字符串，逗号分隔每一项               | 返回一个字符串 |
| join('分隔符') | 把数组转换成字符串，可以添加分隔符，来分隔每一项 | 返回一个字符串 |

**（7）其余**

还有很多方法，具体查看 MDN 文档。

| 方法名      | 说明                                    | 返回值                                         |
| ----------- | --------------------------------------- | ---------------------------------------------- |
| concat()    | 连接两个或多个数组，不影响原数组        | 返回一个新的数组                               |
| slice()     | 数组截取 slice(begin, end)              | 返回被截取项目的新数组                         |
| splice() \* | 数组删除 splice(第几个开始，要删除个数) | 返回被删除项目的新数组，注意：这个会影响原数组 |

## 11.7 字符串对象

**（1）基本包装类型**

基本包装类型：把简单数据类型包装成为了复杂数据类型。

补充：

- 复杂数据类型（对象）才有属性和方法，而简单数据类型是没有属性和方法；

- 特殊情况，基本包装类型。

例子：

```js
//简单数据类型为什么会有length属性？
var str = "andy";
console.log(str.length); //输出结果 4

//基本包装类型：
var temp = new String("andy"); // (1)把简单的数据类型包装为复杂的数据类型
str = temp; // (2)把临时变量的值给str
temp = null; // (3)销毁这个临时变量
```

**（2）字符串的不可变**

指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

```js
var str = "";
for (var i = 0; i < 100000; i++) {
  str += i;
}
console.log(str); // 这个结果需要花费大量时间来显示。因此，不要进行大量重新赋值字符串
```

**（3）根据字符返回位置**

字符串所有的方法，都不会修改字符串本身（<u>字符串是不可变的</u>），操作完成会返回一个新的字符串。

| 方法名                                     | 说明                                                                          |
| ------------------------------------------ | ----------------------------------------------------------------------------- |
| indexOf(&#39;要查找的字符&#39;,开始的位置) | 返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是 index 索引号 |
| lastIndexOf()                              | 从后往前找，只找第一个匹配的                                                  |

**（4）根据位置返回字符（重点）**

| 方法名                          | 说明                                                     | 使用                            |
| ------------------------------- | -------------------------------------------------------- | ------------------------------- |
| charAt(index)                   | 返回指定位置的字符（index 字符串的索引号）               | str.charAt(3)                   |
| charCodeAt(index)               | 获取指定位置处字符 ASCII 码（index 索引号）              | str.charCodeAt(3)               |
| 对象[index] 或者 对象['属性名'] | 获取指定位置处字符 或者 判断是否有该属性，得到的是属性值 | html5,IE8+支持，和 charAt()等效 |

```js
// 1.charAt(index) 根据位置返回字符
var str = "andy";
console.log(str.charAt(3));
//遍历所有的字符
for (var i = 0; i < str.length; i++) {
  console.log(str.charAt(i));
}

// 2.charCodeAt(index)
console.log(str.charCodeAt(0)); //97

// 3.str[index]
console.log(str[0]); //a
```

- str[index]，可以用于判断是否有该属性，对象['属性名']

```js
var obj = {
    age: 18;
    sex: '男';
}
if(obj['age']) {
    console.log('里面有该属性');
} else {
    console.log('没有该属性');
}
```

**（5）字符串操作方法（重点）**

| 方法名                    | 说明                                                                              |
| ------------------------- | --------------------------------------------------------------------------------- |
| concat(str1,str2,str3...) | concat()方法用于连接两个或多个字符串。拼接字符串等效于+，+更常用                  |
| substr(start, length)     | 从 start 位置开始（索引号），length 取到的个数 （重点记住）                       |
| slice(start, end)         | 从 start 位置开始，截取到 end 位置，end 取不到（这两个都是索引号）                |
| substring(start, end)     | 从 start 位置开始，截取到 end 位置，end 取不到，基本和 slice 相同，但是不接受赋值 |

**（6）其他**

| 方法名                                                 | 说明           |
| ------------------------------------------------------ | -------------- |
| replace('被替换的字符串', '要替换为的字符串')          | 替换字符       |
| split('分隔符') //分隔符取决于字符串中是用什么分隔符的 | 字符转换为数组 |
| toUpperCase()                                          | 转换大写       |
| toLowerCase()                                          | 转换小写       |

例子：

```js
// replace()方法
//有一个字符串'abhsojndoowhwo' 要求把里面所有的o替换为+
var str = "abhsojndoowhwo";
while (str.indexOf("o") !== -1) {
  str = str.replace("o", "+");
}
console.log(str1);

//split()方法
var str = "a,b,c,d";
console.log(str.split(",")); // 返回的是一个数组 [a, b, c, d]
```

# 12. JavaScript 简单类型与复杂类型

**（1）简单数据类型**

- 单类型又叫做基本数据类型或者值类型。

- 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型
  如：string ，number，boolean，undefined，null

```js
// 简单数据类型 null 返回的是一个空的对象 object
var timer = null;
console.log(typeof timer); //object
//因此，如果有个变量我们以后打算存储为对象，暂时没有想好放啥，这个时候就给 null
```

**（2）复杂数据类型**

- 复杂类型又叫做引用类型。

- 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型。
- 通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等

---

**堆和栈：**

注意：JavaScript 中没有堆栈的概念，通过堆栈的方式，可以更容易理解代码的一些执行方式。

堆栈空间分配区别：

- 栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。**简单数据类型存放到栈里面**
- 堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。**复杂数据类型存放到堆里面**

![](images\图片3.png)

## 12.1 数据类型内存分配

**简单类型和复杂数据类型的内存分配**

- 简单数据类型（值类型）：存放的是值（是放在栈里面，里面直接开辟一个存放的空间）。

  （其中，对于重新赋值：字符串是直接开辟一个新的空间；值是直接在原空间替换）

- 复杂数据类型（引用类型）：首先在栈空间里存放地址（引用类型变量），十六进制的；真正的对象实例存放在堆空间中（是由这个地址指向堆里面的数据）。

## 12.2 数据类型传参

**（1）简单类型传参**

函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。

例子：

```js
function fn(a) {
    a++;
    console.log(a); //输出结果 11
}
var x = 10;
fn(x);
console.log(x)； //输出结果 10
```

![](images\QQ截图20201224110406.png)

**（2）复杂类型传参**

函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

例子：

```js
function Person(name) {
  this.name = name;
}
function f1(x) {
  // x = p
  console.log(x.name); // 2. 这个输出什么 ?  香蕉
  x.name = "苹果";
  console.log(x.name); // 3. 这个输出什么 ?  苹果
}
var p = new Person("香蕉");
console.log(p.name); // 1. 这个输出什么 ?  香蕉
f1(p);
console.log(p.name); // 4. 这个输出什么 ?  苹果
```

![](images\QQ截图20201224111421.png)

# 13. 拓展

## 13.1 编译语言和解释语言

区别：转换为机器语言的时间点不一样。（编译语言是要全部代码完成后再编译；解释语言是一行一行编译。）

编译语言：Java；解释语言：JavaScript

## 13.2 标识符、关键字、保留字

**（1）标识符**

标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。

标识符不能是关键字或保留字。

**（2）关键字**

关键字：是指 JS 本身已经使用了的字，不能再用它们充当变量名、方法名。

包括：break、case、catch、continue、default...

**（3）保留字**

保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能

使用它们当变量名或方法名。

包括：boolean、byte、char...

## 13.3 JavaScript 命名规范以及语法格式

**（1）标识符命名规范**

- 变量、函数的命名必须要有意义
- 变量的名称一般用名词
- 函数的名称一般用动词

**（2）操作符规范**

操作符的左右两侧各保留一个空格。

**（3）单行注释规范**

单行注释前面注意有个空格。

**（4）其他规范**

```js
if (true) {
  //括号前后有空格
}
for (var i = 0; i <= 100; i++) {}
```
